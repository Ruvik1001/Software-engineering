# Лабораторная работа 1: Документирование архитектуры в Structurizr

## Цель работы

Получить навык в описании архитектуры в стиле Architecture As A Code и проектировании системы «сверху вниз».

## Задание

Выполнено документирование архитектуры системы планирования задач с использованием Structurizr DSL.

## Выбранный вариант

**Вариант 10: Планирование задач**  
Аналог: [LeaderTask](https://www.leadertask.ru/)

### Описание системы

Система планирования задач предназначена для управления целями и задачами пользователей. Основные сущности системы:

- **Цель** - долгосрочная цель пользователя
- **Задача** - конкретная задача на пути к достижению цели
- **Исполнитель** - пользователь системы

### Требования к API

Система должна предоставлять следующий функционал:

- Создание нового пользователя
- Поиск пользователя по логину
- Поиск пользователя по маске имени и фамилии
- Создание новой цели
- Получение списка всех целей
- Создание новой задачи на пути к цели
- Получение всех задач цели
- Изменение статуса задачи в цели

## Анализ системы

### Роли пользователей

1. **Пользователь (Исполнитель)** - основной пользователь системы, который:
   - Создает и управляет своими целями
   - Создает задачи для достижения целей
   - Отслеживает прогресс выполнения задач
   - Изменяет статусы задач

### Внешние системы

1. **Email Service** - внешний сервис для отправки уведомлений:
   - Отправка уведомлений пользователям о создании новых задач
   - Уведомления об изменении статуса задач
   - Напоминания о дедлайнах задач

2. **SSO Authentication Services** - внешние сервисы аутентификации:
   - Аутентификация через Single Sign-On (Google, Microsoft и др.)
   - OAuth2/OpenID Connect протоколы

## Архитектура системы

### Software System

**Task Planning System** - основная система планирования задач, которая включает следующие контейнеры:

### Контейнеры системы

#### Веб-уровень

1. **Nginx** (Nginx)
   - Веб-сервер и обратный прокси для маршрутизации запросов
   - Отдача статического контента
   - Балансировка нагрузки между инстансами сервисов в разнесенной сетевой структуре

2. **Web Application** (React)
   - Веб-интерфейс для взаимодействия пользователей с системой
   - Предоставляет пользовательский интерфейс для управления целями и задачами
   - Поддержка WebSocket для шаринга календарей

#### API и сервисы

3. **Proxy Service** (Python/FastAPI)
   - Слой изоляции и единая точка входа для всех API запросов
   - Обрабатывает запросы и маршрутизирует к соответствующим сервисам
   - Проверка аутентификации перед маршрутизацией
   - Не имеет прямого доступа к базе данных - работает только как промежуточный слой

4. **User Service** (Python)
   - Управление персональными данными пользователей
   - Реализует функционал создания пользователя и поиска по логину/имени
   - Управление профилями пользователей

5. **Auth Service** (Python)
   - Авторизация и аутентификация пользователей
   - Генерация и валидация JWT токенов
   - Аутентификация через логин/пароль
   - Интеграция с SSO провайдерами (OAuth2/OpenID Connect)

6. **Goal Service** (Python)
   - Управление целями пользователей
   - Реализует создание целей и получение списка целей

7. **Task Service** (Python)
   - Управление задачами
   - Реализует создание задач, изменение статуса, получение задач цели
   - Публикует события о создании/изменении задач в RabbitMQ

8. **Notification Service** (Python)
   - Управление уведомлениями с поддержкой различных менеджеров
   - Обработка событий из RabbitMQ
   - Отправка уведомлений через email, push, SMS

9. **Calendar Service** (Python)
   - Управление календарями пользователей
   - Шаринг календарей между пользователями
   - Поддержка WebSocket для real-time обновлений

#### Инфраструктура

10. **RabbitMQ** (RabbitMQ)
    - Брокер сообщений для асинхронной обработки уведомлений
    - Обработка событий системы через AMQP протокол

11. **Redis** (Redis)
    - Кеш для хранения сессий, JWT токенов
    - Кеширование часто запрашиваемых данных
    - Инвалидация кеша при обновлении данных

12. **PostgreSQL Database** (PostgreSQL)
    - Хранение информации о пользователях, целях, задачах и календарях
    - Обеспечивает целостность данных и транзакционность операций

#### Мониторинг

13. **Prometheus** (Prometheus)
    - Система мониторинга и сбора метрик производительности
    - Сбор метрик со всех сервисов системы

14. **Grafana** (Grafana)
    - Система визуализации метрик и дашбордов
    - Визуализация данных из Prometheus

### Взаимодействие между контейнерами

- **Пользователь** обращается к системе через **Nginx** по HTTPS
- **Nginx** проксирует запросы к **Web Application** (статический контент) и **Proxy Service** (API)
- **Nginx** выполняет балансировку нагрузки между инстансами сервисов в разнесенной сетевой структуре
- **Proxy Service** (слой изоляции) проверяет аутентификацию через **Auth Service** и маршрутизирует запросы к соответствующим сервисам
- **Proxy Service** не имеет прямого доступа к базе данных - работает только как промежуточный слой маршрутизации
- Все бизнес-сервисы (User Service, Goal Service, Task Service, Calendar Service) взаимодействуют с **PostgreSQL Database** через JDBC
- **Auth Service** использует **Redis** для хранения JWT токенов и сессий
- Бизнес-сервисы используют **Redis** для кеширования часто запрашиваемых данных
- **Task Service**, **Goal Service** и **Calendar Service** публикуют события в **RabbitMQ**
- **Notification Service** подписывается на события из **RabbitMQ** и отправляет уведомления через **Email Service** по SMTP
- **Auth Service** интегрируется с **SSO Authentication Services** через OAuth2/OpenID Connect
- **Prometheus** собирает метрики со всех сервисов, **Grafana** визуализирует их

## Диаграммы

### 1. System Context (C1)

Диаграмма контекста системы показывает:
- Взаимодействие пользователей с системой
- Связь с внешними системами (Email Service, SSO Authentication Services)
- Границы системы планирования задач

### 2. Container (C2)

Диаграмма контейнеров показывает:
- Внутреннюю структуру системы с 14 контейнерами
- Все контейнеры и их технологии
- Взаимодействие между контейнерами
- Протоколы взаимодействия (HTTPS/REST, JDBC, SMTP, AMQP, WebSocket, OAuth2/OpenID Connect)

### 3. Dynamic - Создание новой задачи

Диаграмма последовательности для сценария создания новой задачи на пути к цели:

1. Пользователь отправляет запрос через веб-интерфейс
2. Nginx проксирует запрос к Proxy Service
3. Proxy Service проверяет аутентификацию через Auth Service
4. Auth Service проверяет JWT токен в Redis
5. Redis возвращает результат проверки
6. Auth Service подтверждает аутентификацию
7. Proxy Service перенаправляет запрос в Task Service
8. Task Service сохраняет задачу в PostgreSQL Database
9. Database подтверждает сохранение с данными созданной задачи
10. Task Service инвалидирует старый кеш задач в Redis и сохраняет новую задачу в кеш (Cache-Aside паттерн с обновлением)
11. Redis подтверждает обновление кеша
12. Task Service публикует событие создания задачи в RabbitMQ
13. RabbitMQ доставляет событие в Notification Service
14. Notification Service отправляет уведомление через Email Service по SMTP
15. Task Service возвращает созданную задачу в Proxy Service
16. Proxy Service возвращает результат в Nginx
17. Nginx отображает созданную задачу пользователю

## Технологии

### Frontend
- **React** - веб-приложение
- **Nginx** - веб-сервер и обратный прокси

### Backend
- **FastAPI (Python)** - Proxy Service (единая точка входа)
- **Python** - все микросервисы (User, Auth, Goal, Task, Notification, Calendar)

### Базы данных и хранилища
- **PostgreSQL** - основная база данных
- **Redis** - кеш и хранение сессий
- **RabbitMQ** - брокер сообщений

### Мониторинг
- **Prometheus** - сбор метрик
- **Grafana** - визуализация метрик

### Протоколы
- **HTTPS/REST** - взаимодействие между клиентом и API
- **JDBC** - взаимодействие с базой данных PostgreSQL
- **SMTP** - отправка email уведомлений
- **AMQP** - обмен сообщениями через RabbitMQ
- **WebSocket** - real-time обновления для шаринга календарей
- **OAuth2/OpenID Connect** - аутентификация через SSO
- **Redis Protocol** - взаимодействие с Redis

## Запуск проекта

### Предварительные требования

- Docker и Docker Compose

### Запуск Structurizr Lite

```bash
cd lab_1
docker-compose up -d
```

После запуска Structurizr Lite будет доступен по адресу: http://localhost:8080

### Просмотр диаграмм

1. Откройте браузер и перейдите на http://localhost:8080
2. Загрузите файл `workspace.dsl` в Structurizr Lite
3. Просмотрите созданные диаграммы:
   - System Context
   - Container
   - Dynamic (CreateTaskDynamic)

## Структура файлов

```
lab_1/
├── README.md                    # Данный файл
├── system_design_task_01.txt   # Исходное задание
├── workspace.dsl                # Модель и диаграммы в формате Structurizr DSL
└── docker-compose.yml          # Конфигурация для запуска Structurizr Lite
```

## Автор

**Руднев В.В.**  
Группа: М8О-105СВ-25  
Университет: МАИ

